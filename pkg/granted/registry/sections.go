package registry

import (
	"fmt"
	"regexp"
	"strings"

	"gopkg.in/ini.v1"
)

func getGrantedGeneratedSections(config *ini.File) []*ini.Section {
	var grantedProfiles []*ini.Section

	isAutogeneratedSection := false
	for _, section := range config.Sections() {
		if section.Name() == ini.DefaultSection {
			continue
		}

		if strings.HasPrefix(section.Name(), "granted_registry_start") && !isAutogeneratedSection {
			isAutogeneratedSection = true
			grantedProfiles = append(grantedProfiles, section)

			continue
		}

		if strings.HasPrefix(section.Name(), "granted_registry_end") {
			isAutogeneratedSection = false
			grantedProfiles = append(grantedProfiles, section)

			continue
		}

		if isAutogeneratedSection {
			grantedProfiles = append(grantedProfiles, section)
		}
	}

	return grantedProfiles

}

func removeAutogeneratedProfiles(configFile *ini.File, awsConfigPath string) error {
	grantedProfiles := getGrantedGeneratedSections(configFile)
	// delete all autogenerated sections if any
	if len(grantedProfiles) > 1 {
		for _, gp := range grantedProfiles {
			configFile.DeleteSection(gp.Name())
		}
	}

	err := configFile.SaveTo(awsConfigPath)
	if err != nil {
		return err
	}

	return nil
}

// return all profiles that are not part of granted registry section.
func getNonGrantedProfiles(config *ini.File) []*ini.Section {
	isAutogeneratedSection := false
	var grantedProfiles []string
	for _, section := range config.Sections() {
		if strings.HasPrefix(section.Name(), "granted_registry_start") && !isAutogeneratedSection {
			isAutogeneratedSection = true
			grantedProfiles = append(grantedProfiles, section.Name())

			continue
		}

		if strings.HasPrefix(section.Name(), "granted_registry_end") {
			isAutogeneratedSection = false
			grantedProfiles = append(grantedProfiles, section.Name())

			continue
		}

		if isAutogeneratedSection {
			grantedProfiles = append(grantedProfiles, section.Name())
		}
	}

	var nonGrantedProfiles []*ini.Section
	for _, sec := range config.Sections() {
		if sec.Name() == ini.DefaultSection {
			continue
		}

		if !Contains(grantedProfiles, sec.Name()) {
			nonGrantedProfiles = append(nonGrantedProfiles, sec)
		}
	}

	return nonGrantedProfiles
}

func generateNewRegistrySection(configFile *ini.File, clonedFile *ini.File, repoURL string, isFirstSection bool) error {
	err := configFile.NewSections(fmt.Sprintf("granted_registry_start %s", repoURL))
	if err != nil {
		return err
	}

	// add "do not edit" msg in the top of autogenerated code.
	if isFirstSection {
		configFile.Section(fmt.Sprintf("granted_registry_start %s", repoURL)).Comment = GetAutogeneratedTemplate()
	}

	localProfiles := getNonGrantedProfiles(configFile)
	var localProfileNames []string

	for _, sec := range localProfiles {
		localProfileNames = append(localProfileNames, sec.Name())
	}

	namespace := formatURLToNamespace(repoURL)

	// iterate each profile section from clonned repo
	// add them to aws config file
	// if there is collision in the profile names then prefix with namespace.
	for _, sec := range clonedFile.Sections() {
		if sec.Name() == ini.DefaultSection {
			continue
		}

		if Contains(localProfileNames, sec.Name()) {
			f, err := configFile.NewSection(appendNamespaceToDuplicateSections(sec.Name(), namespace))
			if err != nil {
				return err
			}

			*f = *sec
			if f.Comment == "" {
				f.Comment = "# profile name has been prefixed due to duplication"
			} else {
				f.Comment = "# profile name has been prefixed due to duplication. \n" + f.Comment
			}

			continue
		}

		f, err := configFile.NewSection(sec.Name())
		if err != nil {
			return err
		}

		*f = *sec
	}

	err = configFile.NewSections(fmt.Sprintf("granted_registry_end %s", repoURL))
	if err != nil {
		return err
	}

	return nil
}

func Contains(arr []string, s string) bool {
	for _, v := range arr {
		if v == s {
			return true
		}
	}

	return false
}

func formatURLToNamespace(repoURL string) string {
	u, _ := parseGitURL(repoURL)

	return u.Repo
}

func appendNamespaceToDuplicateSections(pName string, namespace string) string {
	regx := regexp.MustCompile(`(.*profile\s+)(?P<name>[^\n\r]*)`)

	if regx.MatchString(pName) {
		matches := regx.FindStringSubmatch(pName)
		nameIndex := regx.SubexpIndex("name")

		return "profile " + namespace + "." + matches[nameIndex]
	}

	return pName
}
