package registry

import (
	"bufio"
	"fmt"
	"log"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"strings"

	grantedConfig "github.com/common-fate/granted/pkg/config"
	"github.com/urfave/cli/v2"
	"gopkg.in/ini.v1"
)

// TODO: Sync command/Add command should create new aws config file if not found.
var SyncCommand = cli.Command{
	Name: "sync",
	Action: func(c *cli.Context) error {

		gConf, err := grantedConfig.Load()
		if err != nil {
			return err
		}

		if len(gConf.ProfileRegistryURLS) < 1 {
			return fmt.Errorf("granted registry not configured. Try adding a git repository with 'granted add https://github.com/your-org/your-registry.git'")
		}

		for index, repoURL := range gConf.ProfileRegistryURLS {
			u, err := url.Parse(repoURL)
			if err != nil {
				return err
			}

			repoDirPath, err := GetRegistryLocation(u)
			if err != nil {
				return err
			}

			// pull the repo here.
			fmt.Printf("git -C %s pull %s %s\n", repoDirPath, "origin", "main")
			cmd := exec.Command("git", "-C", repoDirPath, "pull", "origin", "main")

			// StderrPipe returns a pipe that will be connected to the command's
			// standard error when the command starts.
			// TODO: Sync command should have silent option and probably log to external log file on error.
			stderr, _ := cmd.StderrPipe()
			if err := cmd.Start(); err != nil {
				log.Fatal(err)
			}

			scanner := bufio.NewScanner(stderr)
			for scanner.Scan() {
				fmt.Println(scanner.Text())
			}

			var r Registry
			_, err = r.Parse(repoDirPath)

			if err != nil {
				return err
			}

			isFirstSection := false
			if index == 0 {
				isFirstSection = true
			}
			if err := Sync(r, repoURL, repoDirPath, isFirstSection); err != nil {
				return err
			}
		}

		return nil
	},
}

func Sync(r Registry, repoURL string, repoDirPath string, isFirstSection bool) error {

	awsConfigPath, err := GetDefaultAWSConfigLocation()
	if err != nil {
		return err
	}

	configFile, err := LoadAWSConfigFile()
	if err != nil {
		return err
	}

	allLocalSections, err := GetNonGrantedProfiles(configFile)
	if err != nil {
		return err
	}

	isAutogeneratedSection := false
	var grantedProfiles []*ini.Section
	for _, section := range configFile.Sections() {
		if strings.HasPrefix(section.Name(), fmt.Sprintf("granted_registry_start %s", repoURL)) && !isAutogeneratedSection {
			isAutogeneratedSection = true
			grantedProfiles = append(grantedProfiles, section)

			continue
		}

		if strings.HasPrefix(section.Name(), fmt.Sprintf("granted_registry_end %s", repoURL)) {
			isAutogeneratedSection = false
			grantedProfiles = append(grantedProfiles, section)

			break
		}

		if isAutogeneratedSection {
			grantedProfiles = append(grantedProfiles, section)
		}
	}

	if len(grantedProfiles) > 1 {
		for _, gp := range grantedProfiles {
			configFile.DeleteSection(gp.Name())
		}
	}

	configFile.SaveTo(awsConfigPath)

	cfg := ini.Empty()
	for _, cfile := range r.AwsConfigPaths {
		filepath := path.Join(repoDirPath, cfile)

		err := cfg.Append(filepath)
		if err != nil {
			return err
		}
	}

	// change the previous section with .local
	// delete the section and create new section with .local prefix.
	for _, sec := range cfg.Sections() {
		for _, ls := range allLocalSections {
			if sec.Name() == ini.DefaultSection {
				continue
			}

			if sec.Name() == ls.Name() {
				f, err := configFile.NewSection(formatNameWithLocalPrefix(ls.Name()))
				// FIXME: The comment doesn't appear.
				f.Comment = "# The profile with this name was already present. Changing the previous profile to .local"
				if err != nil {
					return err
				}
				*f = *ls
			}

			configFile.DeleteSection(sec.Name())
		}
	}

	err = configFile.NewSections(fmt.Sprintf("granted_registry_start %s", repoURL))
	if err != nil {
		return err
	}

	// add "do not edit" msg in the top of autogenerated code.
	if isFirstSection {
		configFile.Section(fmt.Sprintf("granted_registry_start %s", repoURL)).Comment = GetAutogeneratedTemplate()
	}

	for _, sec := range cfg.Sections() {
		if sec.Name() == ini.DefaultSection {
			continue
		}

		f, err := configFile.NewSection(sec.Name())
		if err != nil {
			return err
		}

		*f = *sec
	}

	err = configFile.NewSections(fmt.Sprintf("granted_registry_end %s", repoURL))
	if err != nil {
		return err
	}

	configFile.SaveTo(awsConfigPath)

	return nil
}

func formatNameWithLocalPrefix(pName string) string {
	regx := regexp.MustCompile(`(.*profile\s+)(?P<name>[^\n\r]*)`)

	if regx.MatchString(pName) {
		matches := regx.FindStringSubmatch(pName)
		nameIndex := regx.SubexpIndex("name")

		return "profile local." + matches[nameIndex]
	}

	return pName

}

func LoadAWSConfigFile() (*ini.File, error) {
	p, err := GetDefaultAWSConfigLocation()
	if err != nil {
		return nil, err
	}

	awsConfig, err := ini.LoadSources(ini.LoadOptions{
		SkipUnrecognizableLines: true,
		AllowNonUniqueSections:  true,
	}, p)
	if err != nil {
		return nil, err
	}

	return awsConfig, nil
}

// Find the ~/.aws/config absolute path based on OS.
func GetDefaultAWSConfigLocation() (string, error) {
	h, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	configPath := filepath.Join(h, ".aws", "config")
	return configPath, nil
}

func GetNonGrantedProfiles(config *ini.File) ([]*ini.Section, error) {
	isAutogeneratedSection := false
	var grantedProfiles []string
	for _, section := range config.Sections() {
		if strings.HasPrefix(section.Name(), "granted_registry_start") && !isAutogeneratedSection {
			isAutogeneratedSection = true
			grantedProfiles = append(grantedProfiles, section.Name())

			continue
		}

		if strings.HasPrefix(section.Name(), "granted_registry_end") {
			isAutogeneratedSection = false
			grantedProfiles = append(grantedProfiles, section.Name())

			continue
		}

		if isAutogeneratedSection {
			grantedProfiles = append(grantedProfiles, section.Name())
		}
	}

	var nonGrantedProfiles []*ini.Section
	for _, sec := range config.Sections() {
		if !contains(grantedProfiles, sec.Name()) {
			nonGrantedProfiles = append(nonGrantedProfiles, sec)
		}
	}

	return nonGrantedProfiles, nil
}

func contains(arr []string, s string) bool {
	for _, v := range arr {
		if v == s {
			return true
		}
	}

	return false
}
