package registry

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"

	grantedConfig "github.com/common-fate/granted/pkg/config"
	"github.com/urfave/cli/v2"
	"gopkg.in/ini.v1"
)

// TODO: Sync command/Add command should create new aws config file if not found.
var SyncCommand = cli.Command{
	Name: "sync",
	Action: func(c *cli.Context) error {

		gConf, err := grantedConfig.Load()
		if err != nil {
			return err
		}

		if gConf.ProfileRegistryURL == "" {
			return fmt.Errorf("granted registry not configured. Try adding a git repository with 'granted add https://github.com/your-org/your-registry.git'")
		}

		u, err := url.Parse(gConf.ProfileRegistryURL)
		if err != nil {
			return err
		}

		repoDirPath, err := GetRegistryLocation(u)
		if err != nil {
			return err
		}

		fmt.Printf("git -C %s pull %s %s\n", repoDirPath, "origin", "main")
		cmd := exec.Command("git", "-C", repoDirPath, "pull", "origin", "main")

		// StderrPipe returns a pipe that will be connected to the command's
		// standard error when the command starts.
		// TODO: Sync command should have silent option and probably log to external log file on error.
		stderr, _ := cmd.StderrPipe()
		if err := cmd.Start(); err != nil {
			log.Fatal(err)
		}

		scanner := bufio.NewScanner(stderr)
		for scanner.Scan() {
			fmt.Println(scanner.Text())
		}

		var r Registry
		_, err = r.Parse(repoDirPath)
		if err != nil {
			return err
		}

		if err := Sync(r, gConf.ProfileRegistryURL, repoDirPath); err != nil {
			return err
		}

		return nil
	},
}

func Sync(r Registry, repoURL string, repoDirPath string) error {

	// Pass options here if necessary.
	cfg := ini.Empty()

	// ini pkg will overwrite the section with same name
	// if config1 & config2 has section with name "abc" then
	// config2 will be returned.
	for _, cfile := range r.AwsConfigPaths {
		filepath := path.Join(repoDirPath, cfile)

		err := cfg.Append(filepath)

		if err != nil {
			return err
		}
	}

	awsConfigPath, err := GetDefaultAWSConfigLocation()
	if err != nil {
		return err
	}

	f, err := os.OpenFile(awsConfigPath, os.O_RDWR, 0666)
	if err != nil {
		return err
	}
	defer f.Close()

	configFileContent, err := os.ReadFile(awsConfigPath)
	if err != nil {
		return err
	}

	// if there is autogenerated string then remove it.
	if HasGrantedGeneratedSection(string(configFileContent)) {
		if err = RemoveAutogeneratedSection(f, GetRegexp(), &configFileContent); err != nil {
			return err
		}
	} else {
		// Move the file cursor to end of line.
		_, err = f.Seek(0, io.SeekEnd)
		if err != nil {
			return err
		}

		// end of line might not be a newline so add couple of new lines.
		if _, err := f.WriteString("\n\n"); err != nil {
			return err
		}
	}

	_, err = f.Seek(0, io.SeekEnd)
	if err != nil {
		return err
	}

	if _, err := f.WriteString(GetAutogeneratedTemplate(repoURL) + "\n"); err != nil {
		return err
	}

	_, err = cfg.WriteTo(f)
	if err != nil {
		return err
	}

	if _, err := f.WriteString(fmt.Sprintf("### GRANTED-REGISTRY-SECTION-END %s] #########", repoURL)); err != nil {
		return err
	}

	return nil

}

// Find the ~/.aws/config absolute path based on OS.
func GetDefaultAWSConfigLocation() (string, error) {
	h, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	configPath := filepath.Join(h, ".aws", "config")
	return configPath, nil
}

func RemoveAutogeneratedSection(f *os.File, r *regexp.Regexp, configFile *[]byte) error {

	// Remove previous autogenerated section with empty string and store in memeory.
	output := r.ReplaceAllString(string(*configFile), "")

	// Clear the content in the file.
	err := f.Truncate(0)
	if err != nil {
		return err
	}

	// Write the in-memeory content to the file.
	_, err = fmt.Fprintln(f, output)
	if err != nil {
		return err
	}

	// commit to file
	f.Sync()

	return nil
}

// regex to check if the provided string starts with '### GRANTED-REGISTRY-SECTION'
// and ends with '### GRANTED-REGISTRY-SECTION-END' words.
func GetRegexp() *regexp.Regexp {
	r, _ := regexp.Compile(`(?s)\n### GRANTED-REGISTRY-SECTION:(.*?)### GRANTED-REGISTRY-SECTION-END.+#`)

	return r
}

// returns true if the provided string contains required regex expression.
func HasGrantedGeneratedSection(fileContent string) bool {
	rex := GetRegexp()

	return rex.MatchString(fileContent)
}
